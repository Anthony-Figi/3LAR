	package  {		import flash.display.MovieClip;	import flash.display.Bitmap;	import flash.geom.ColorTransform;	import com.caurina.transitions.Tweener;	import flash.events.*;	import flash.net.*;	import flash.utils.getTimer;	import flash.display.Loader;		import com.as3nui.nativeExtensions.air.kinect.Kinect;	import com.as3nui.nativeExtensions.air.kinect.KinectSettings;	import com.as3nui.nativeExtensions.air.kinect.events.CameraImageEvent;	import com.as3nui.nativeExtensions.air.kinect.constants.CameraResolution;	import com.as3nui.nativeExtensions.air.kinect.data.DeviceCapabilities;	import com.as3nui.nativeExtensions.air.kinect.data.SkeletonJoint;	import com.as3nui.nativeExtensions.air.kinect.data.User;	import com.as3nui.nativeExtensions.air.kinect.events.CameraImageEvent;	import com.as3nui.nativeExtensions.air.kinect.events.DeviceErrorEvent;	import com.as3nui.nativeExtensions.air.kinect.events.DeviceEvent;	import com.as3nui.nativeExtensions.air.kinect.events.DeviceInfoEvent;	import com.as3nui.nativeExtensions.air.kinect.events.UserEvent;		import com.tonybeltramelli.airkinect.ActionManager;	import com.tonybeltramelli.airkinect.debug.KinectDebugger;	import com.tonybeltramelli.airkinect.userAction.dispatcher.ActionSignalDispatcher;	import com.tonybeltramelli.airkinect.userAction.event.KinectGestureEvent;	import com.tonybeltramelli.airkinect.userAction.gesture.HorizontalSwipe;	import com.tonybeltramelli.airkinect.userAction.gesture.LeftSwipe;	import com.tonybeltramelli.airkinect.userAction.gesture.RightSwipe;	import com.tonybeltramelli.airkinect.userAction.gesture.UpSwipe;	import com.tonybeltramelli.airkinect.userAction.gesture.DownSwipe;	import com.tonybeltramelli.airkinect.userAction.gesture.DepthSwipe;	import com.tonybeltramelli.airkinect.userAction.gesture.settings.part.GesturePart;	import com.tonybeltramelli.airkinect.userAction.movement.JumpMovement;				public class main extends MovieClip {				public var tree;		public var leaves;		public var foreground;		public var tweetArray:Array = new Array();		public var treeArray:Array = new Array();		public var kin:Kinect;		public var head:headMarker;		public var rightHand:rightMarker;		public var leftHand:leftMarker;		public var userOne;		public var userTwo;		public var userIn:Boolean;		public var oldHeadX:Number;		public var oldTreeZ:Number;		public var loadingKinect:loadingSign;		public var trackingSkel:trackingOn;		public var frames:int=0;		public var prevTimer:Number=0;		public var curTimer:Number=0;		public var backgrnd:backgroundArt;		public var sunny:sun;		public var cloudCover:clouds;		public var frontNight:night;		public var backNight:night;		private var device:Kinect;		private var _actionManager : ActionManager;		private var _debugger : KinectDebugger;		public var focusTree:Number;		public var animating:Boolean = false;				public  var jcode:jsoncode;		//tweet hashtag holding arrays		public var swapSight:Array = new Array();		public var via:Array = new Array();		public var airmen:Array = new Array();		public var cp2:Array = new Array();		public var threelar:Array = new Array();		public var augo:Array = new Array();		public var mctv:Array = new Array();		public var dragon:Array = new Array();		public var edge:Array = new Array();		public var other:Array = new Array();				public var apple:Array = new Array();		public var found:Boolean;		public var loadedTweets:Boolean = false;		//public var trunk1:trunk;				public function main() {						this.tweetArray = tweetArray;			this.treeArray = treeArray;			this.loadingKinect = new loadingSign;			this.userOne = userOne;			this.userTwo = userTwo;			this.backNight = new night(this, true);			this.backgrnd = new backgroundArt(this);			this.sunny = new sun (this);			this.frontNight = new night (this, false);			this.cloudCover = new clouds();						this.jcode = new jsoncode();			//this.trunk1 = new trunk();						this.swapSight = swapSight;			this.via = via;			this.airmen = airmen;			this.cp2 = cp2;			this.threelar = threelar;			this.augo = augo;			this.mctv = mctv;			this.dragon = dragon;			this.edge = edge;			this.found = found;			this.other = other;			this.apple = apple;			this.loadedTweets = false;						this.addChild(this.backNight);			this.addChild(this.sunny);			this.addChild(this.cloudCover);			this.addChild(this.backgrnd);						initForest();			//initKinect();			//initGestures();			this.addChild(this.frontNight);			stage.addEventListener(KeyboardEvent.KEY_DOWN, keyDownHandler);			stage.addEventListener(Event.ENTER_FRAME, _enterFrame);		}		//////////////////////////FOREST AND TWEET FUNCTIONS///////////////////////////////////////////////////		public function initForest() {			//Array that holds tree tags			var tags:Array = new Array("swapSight", "via","airmen","cp2","threelar","augo","mctv","dragon","edge","other");			//TO BO EDITED LATER			var fruitTags:Array = new Array("apple", "apricot", "greenApple", "mango", "redPear", "banana", "pear", "lemon", "apple", "apricot");						//Add Trees to array			for (var i:Number=0; i<tags.length; i++) {				var tree = new trunk(this, i, tags[i]);//, fruitTags[i]				tree.cacheAsBitmap = true;				//trace("created TREES");				treeArray.push(tree);				};						//treeArray.sortOn( "z", Array.NUMERIC | Array.DESCENDING );			addChild(treeArray[0]);			focusTree = 0			//addChild(this.loadingKinect);					}					public function _enterFrame(event : Event) : void {			sortTweets();		}				public function sortTweets() {			var count:int = 1;			//jcode.changed checks if jsoncode changed it's state, if yes then sort new tweets			if(jcode.changed) {				trace("CHECKING TWEETS");				jcode.changed = false;				//trace(""+jcode.tweetUsers);			for (var i:Number=0; i<jcode.tweets.length; i++){				//trace ("tweet numer"+ (i+1) + jcode.tweets[i]);				found = false;				var repeated:Array = new Array();				var user:String = jcode.tweets[i].user+"";				//trace(user+"USER OF THE TWITTER");				var myString = jcode.tweets[i]+"";				var fruitTweets = jcode.tweetUsers[i]+"";				trace("fruits tweets " + fruitTweets);				if(myString.indexOf("#threelar") > -1) {					if(threelar.indexOf(myString) == -1){					threelar.push(myString);					   }					found = true;							}				if(myString.indexOf("#via") > -1) {					if(via.indexOf(myString) == -1){					via.push(myString);					}					found = true;				}				if(myString.indexOf("#airmen") > -1) {					if(airmen.indexOf(myString) == -1){					airmen.push(myString);					}					found = true;				}				if(myString.indexOf("#cp2") > -1) {					if(cp2.indexOf(myString) == -1){					cp2.push(myString);					}					found = true;				}				if(myString.indexOf("#swapsight") > -1) {					if(swapSight.indexOf(myString) == -1){					swapSight.push(myString);				}				//if(myString.indexOf("@flee1906") > -1) {					//treeArray[4].createFruit("RedApple", tweet, x, y, index);				//}					found = true;				}				if(myString.indexOf("#augo") > -1) {					if(augo.indexOf(myString) == -1){					augo.push(myString);					}					found = true;				}				if(myString.indexOf("#mctv") > -1) {					if(mctv.indexOf(myString) == -1){					mctv.push(myString);					}					found = true;				}				if(myString.indexOf("#dragon") > -1) {					if(dragon.indexOf(myString) == -1){					dragon.push(myString);					}					found = true;				}				if(myString.indexOf("#edge") > -1) {					if(edge.indexOf(myString) == -1){					edge.push(myString);					}					found = true;				}				if(fruitTweets.indexOf("nurmerey") > -1){					if(apple.indexOf(fruitTweets) == -1){					apple.push(fruitTweets);					}					found = true;				}				if(found==false){					if(other.indexOf(myString) == -1){					other.push(myString);					}				}								//}			}			trace("apple " + apple);			/*trace("length is : "+jcode.tweets.length);			trace("swapsight: "+swapSight);			trace("via :"+ via);			trace("airmen: "+ airmen);			trace("cp2: " + cp2);			trace("threelar: "+ threelar);			trace("repeated :"+ repeated);			trace("augo: "+ augo);			trace("mctv: "+ mctv);			trace("dragon: "+dragon);			trace("edge: "+ edge);			trace("other tweets: "+other);*/			//if tweets aren't up on trees yet, then load them			//load trees according to tweet tags			for(var i2:Number = 0; i2<treeArray.length; i2++) {					//trace("WORKING?");					if(this.loadedTweets == false) {						this.treeArray[i2].oldTweetArrayLength = (this[treeArray[i2].tweetTag] as Array).length;						this.loadedTweets = true;					};					treeArray[i2].loadTweetArray(this[treeArray[i2].tweetTag]);			}		}		}				//////////////////////////GESTURE FUNCTIONS///////////////////////////////////////////////////		public function keyDownHandler(event:KeyboardEvent):void {			trace("KEYBOARD!");			if(event.keyCode == 39) {				trace("left");				panTreesRight(null);			}			else if(event.keyCode == 37) {				trace("right");				panTreesLeft(null);			}		}				public function initGestures() {			//// Right Hand SWip[ed			var rightHandLeftSwipe : LeftSwipe = new LeftSwipe(GesturePart.RIGHT_HAND);			rightHandLeftSwipe.dispatcher.addEventListener(KinectGestureEvent.LEFT_SWIPE, panTreesLeft);			_actionManager.add(rightHandLeftSwipe);						var rightHandRightSwipe : RightSwipe = new RightSwipe(GesturePart.RIGHT_HAND);			rightHandRightSwipe.dispatcher.addEventListener(KinectGestureEvent.RIGHT_SWIPE, panTreesRight);			_actionManager.add(rightHandRightSwipe);						var rightHandUpSwipe : UpSwipe = new UpSwipe(GesturePart.RIGHT_HAND);			rightHandUpSwipe.dispatcher.addEventListener(KinectGestureEvent.UP_SWIPE, timeForward);			_actionManager.add(rightHandUpSwipe);						var rightHandDownSwipe : DownSwipe = new DownSwipe(GesturePart.RIGHT_HAND);			rightHandDownSwipe.dispatcher.addEventListener(KinectGestureEvent.DOWN_SWIPE, timeBack);			_actionManager.add(rightHandDownSwipe);					}				public function timeForward(event: Event) {			this.sunny.changeTime(5);			trace("timeFORWARD");		}				public function timeBack(event: Event) {			this.sunny.changeTime(-5);			trace("timeBACKWARD");		}				//Tracks Between Trees using keyboard/gestures		public function panTreesLeft(event : Event) {			if(focusTree != 9 && animating == false) {				trace("panLEFT", focusTree);				animating = true;				Tweener.addTween(treeArray[focusTree], {							 x:-100,							 scaleX:0.2,							 scaleY:0.2,							 alpha:0.2,							 time:.5, 							 onComplete:function() { removeChild(treeArray[focusTree]); focusTree += 1; }							 });				addChild(treeArray[focusTree+1]);				Tweener.addTween(treeArray[focusTree+1], {							 x:700,							 scaleX:1,							 scaleY:1,							 alpha:1,							 time:.5, 							 onComplete:function() {animating = false;}							 });				animating = false;			}		}						public function panTreesRight(event : Event) {			if(focusTree != 0 && animating == false) {				trace("panRIGHT", focusTree);				animating = true;				Tweener.addTween(treeArray[focusTree], {							 x:1400,							 scaleX:0.2,							 scaleY:0.2,							 alpha:0.2,							 time:.5, 							 onComplete:function() { removeChild(treeArray[focusTree]); focusTree -= 1;}							 });				addChild(treeArray[focusTree-1]);				Tweener.addTween(treeArray[focusTree-1], {							 x:700,							 scaleX:1,							 scaleY:1,							 alpha:1,							 time:.5,							 onComplete:function() {animating = false;}							 });							}		}		//////////////////////////KINECT AND USER FUNCTIONS///////////////////////////////////////////////////		public function initKinect() {			if (Kinect.isSupported()) {				device = Kinect.getDevice();				var settings:KinectSettings = new KinectSettings();				settings.skeletonEnabled = true;            	settings.skeletonMirrored = true;				settings.depthEnabled = true;				device.addEventListener(UserEvent.USERS_WITH_SKELETON_ADDED, skelIn);            	device.addEventListener(UserEvent.USERS_WITH_SKELETON_REMOVED, skelOut);								device.start(settings);				device.addEventListener(DeviceEvent.STARTED, _started);				_debugger = new KinectDebugger(device, true, true, false, false);				addChild(_debugger);				_actionManager = new ActionManager(stage.frameRate);				trace("actionManager ON");			}			else { 			trace ("NO DEVICE"); 			}		}				private function _started(event : DeviceEvent) : void {			device.removeEventListener(DeviceEvent.STARTED, _started);			addEventListener(Event.ENTER_FRAME, _enterFrame);		}		/*private function _enterFrame(event : Event) : void {			sortTweets();			for each(var user : User in device.users)			{				//draw the kinect feedback in the debugger				_debugger.draw(user);								//ask your ActionManager to compute and analyze user's actions				_actionManager.compute(user);				}		}*/						public function skelIn(event:UserEvent):void {						trace("SKELETON ON!");			this.userOne = event.users[0];			_actionManager.compute(this.userOne);			_debugger.draw(this.userOne);			/*if (event.users.length == 0){				this.userOne = event.users[0];				userIn = true;			}			else if (event.users.length == 1){				this.userTwo = event.users[1];			}*/						var headPosX = this.userOne.skeletonJoints[0].position.depth.x*4;			var headPosZ = this.userOne.skeletonJoints[0].position.world.z;						var leftHandX = this.userOne.skeletonJoints[5].position.depth.x*4;			var leftHandY = this.userOne.skeletonJoints[5].position.depth.y*4;			var leftHandZ = this.userOne.skeletonJoints[5].position.world.z;			leftHand = new leftMarker(leftHandX, leftHandY);			addChild(leftHand);						var rightHandX = this.userOne.skeletonJoints[8].position.depth.x*4;			var rightHandY = this.userOne.skeletonJoints[8].position.depth.y*4;			var rightHandZ = this.userOne.skeletonJoints[8].position.world.z;			rightHand = new rightMarker(rightHandX, rightHandY);			addChild(rightHand);			//head = new headMarker(headPosX);			//sets up starting value so the movement difference can be measured. 						oldHeadX = headPosX;			oldTreeZ = rightHandZ;			if(this.loadingKinect.stage != null)  {          			removeChild(this.loadingKinect);   			};			//addChild(head);			device.addEventListener(UserEvent.USERS_UPDATED, updateSkel);					}				public function skelOut(event:UserEvent):void {			userIn = false;			trace("SKELETON OFF!");			removeChild(leftHand);			removeChild(rightHand);			event.users.pop();			device.removeEventListener(UserEvent.USERS_UPDATED, updateSkel);		}				//Takes new head position data and sends it the relevant environment update functions. 		public function updateSkel(event:UserEvent):void {			var headX = this.userOne.skeletonJoints[0].position.depth.x*4; 	  		var headZ = this.userOne.skeletonJoints[0].position.world.z; 			var treeXDiff = headX - oldHeadX;			oldHeadX = headX;						leftHand.x = this.userOne.skeletonJoints[5].position.depth.x*4;			leftHand.y = this.userOne.skeletonJoints[5].position.depth.y*4;			var updateLeftZ = this.userOne.skeletonJoints[5].position.depth.x*4;			var treeZDiff = headZ - oldTreeZ;			oldTreeZ = headZ;									rightHand.x = this.userOne.skeletonJoints[8].position.depth.x*4;			rightHand.y = this.userOne.skeletonJoints[8].position.depth.y*4;			//trace(treeZDiff);			/*if(treeZDiff > 20 || treeZDiff < -20) {				trace("UPDATEZ", treeZDiff);				updateTreesZ(treeZDiff);			};			//trace(treeXDiff);			if(treeXDiff > 40 || treeXDiff < -40) {				trace("UPDATEX", treeXDiff);				updateTreesX(treeXDiff); 			};*/					}				public function randomRange(minNum:Number, maxNum:Number):Number {			return (Math.floor(Math.random()*(maxNum - minNum +1)) + minNum);		}				//Iterates over each tree and updates their X Position		public function updateTreesX(treeXDiff) {			for (var q:Number=0; q<this.treeArray.length;q++){				var currentTree = this.treeArray[q];				currentTree.cacheAsBitmap = true;				if (currentTree.z < 0) {					var positiveZ = -1*currentTree.z;				}				else {						positiveZ = currentTree.z;				};				var tweenerX = currentTree.x-(treeXDiff/((positiveZ+1000)/3000));				//trace(tweenerX);				currentTree.x = tweenerX;				/*Tweener.removeTweens(currentTree)				Tweener.addTween(currentTree, {							 x:tweenerX, 							 time:0.05							 });*/				};			//trace("Updated");		}				//Iterates over each tree and updates their z position and alpha		public function updateTreesZ(treeZDiff) {			//trace ("Update", treeZDiff);			for (var q:Number=0; q<treeArray.length;q++){				var currentTree = this.treeArray[q];				if(q == 9) {					var treeBehind = 1; 				}				else {					treeBehind = this.treeArray[q+1].z;				};				//trace(treeBehind);					currentTree.cacheAsBitmap = true;					//Tweener.removeTweens(currentTree)										//Adjusts scale depending on keyboard press/mouse scroll/gesture					if (currentTree.z > -600 && currentTree.z < 6000) {						var newZ = currentTree.z + treeZDiff;						currentTree.z += treeZDiff;						/*Tweener.addTween(currentTree, {							 z:newZ, 							 time:0.6							 });*/					}					else if (currentTree.z > 6000) {						if (treeZDiff < 0) {							currentTree.z += treeZDiff;							/*newZ = currentTree.z + treeZDiff;							Tweener.addTween(currentTree, {							 z:newZ, 							 time:0.6							 });*/						}					}					else if (currentTree.z < -600) {						if (treeZDiff > 0 && treeBehind > 0) {							trace("CURRENT", currentTree.z); 							trace("BEHIND", treeBehind);							currentTree.z += treeZDiff;							/*newZ = currentTree.z + treeZDiff;							Tweener.addTween(currentTree, {							 z:newZ, 							 time:0.6							 });*/						}					};										//Adjust opacity depending on zPos					if (currentTree.z < -100 && currentTree.z > -300) {						currentTree.alpha = 1-((currentTree.z+100)/-200);					}					else if (currentTree.z < -300) {						currentTree.alpha = 0;					}					else if (currentTree.z > 6000) {						currentTree.alpha = 0;					}					else if (currentTree.z > -100 && currentTree.z < 2000) {						currentTree.alpha = 1;					}					else if (currentTree.z < 6000 && currentTree.z > 2000) {						currentTree.alpha = 1-((currentTree.z-2000)/4000);					};													}					}								function performFrameTest(e:Event):void {			frames+=1;			curTimer=getTimer();			if(curTimer-prevTimer>=1000){			trace("FPS: "); trace(Math.round(frames*1000/(curTimer-prevTimer)));			prevTimer=curTimer;			frames=0;			}		}				public function tester(event : Event) {			trace("TESTED OK!");		}					}}