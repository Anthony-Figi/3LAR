	package  {		import flash.display.MovieClip;	import flash.display.Bitmap;	import flash.geom.ColorTransform;	import com.caurina.transitions.Tweener;	import flash.events.*;	import flash.net.*;	import flash.utils.getTimer;	import flash.display.Loader;		import com.as3nui.nativeExtensions.air.kinect.Kinect;	import com.as3nui.nativeExtensions.air.kinect.KinectSettings;	import com.as3nui.nativeExtensions.air.kinect.events.CameraImageEvent;	import com.as3nui.nativeExtensions.air.kinect.constants.CameraResolution;	import com.as3nui.nativeExtensions.air.kinect.data.DeviceCapabilities;	import com.as3nui.nativeExtensions.air.kinect.data.SkeletonJoint;	import com.as3nui.nativeExtensions.air.kinect.data.User;	import com.as3nui.nativeExtensions.air.kinect.events.CameraImageEvent;	import com.as3nui.nativeExtensions.air.kinect.events.DeviceErrorEvent;	import com.as3nui.nativeExtensions.air.kinect.events.DeviceEvent;	import com.as3nui.nativeExtensions.air.kinect.events.DeviceInfoEvent;	import com.as3nui.nativeExtensions.air.kinect.events.UserEvent;		import com.tonybeltramelli.airkinect.ActionManager;	import com.tonybeltramelli.airkinect.debug.KinectDebugger;	import com.tonybeltramelli.airkinect.userAction.dispatcher.ActionSignalDispatcher;	import com.tonybeltramelli.airkinect.userAction.event.KinectGestureEvent;	import com.tonybeltramelli.airkinect.userAction.gesture.HorizontalSwipe;	import com.tonybeltramelli.airkinect.userAction.gesture.LeftSwipe;	import com.tonybeltramelli.airkinect.userAction.gesture.UpSwipe;	import com.tonybeltramelli.airkinect.userAction.gesture.DepthSwipe;	import com.tonybeltramelli.airkinect.userAction.gesture.settings.part.GesturePart;	import com.tonybeltramelli.airkinect.userAction.movement.JumpMovement;				public class main extends MovieClip {				public var tree;		public var leaves;		public var foreground;		public var tweetArray:Array = new Array();		public var treeArray:Array = new Array();		public var kin:Kinect;		public var head:headMarker;		public var rightHand:rightMarker;		public var leftHand:leftMarker;		public var userOne;		public var userTwo;		public var userIn:Boolean;		public var oldHeadX:Number;		public var oldTreeZ:Number;		public var loadingKinect:loadingSign;		public var trackingSkel:trackingOn;		public var frames:int=0;		public var prevTimer:Number=0;		public var curTimer:Number=0;		public var backgrnd:backgroundArt;		public var sunny:sun;		public var nightly;night;		private var device:Kinect;		private var _actionManager : ActionManager;		private var _debugger : KinectDebugger;						public function main() {						this.tweetArray = tweetArray;			this.treeArray = treeArray;			this.loadingKinect = new loadingSign;			this.userOne = userOne;			this.userTwo = userTwo;			this.backgrnd = new backgroundArt(this);			this.sunny = new sun (this);			this.nightly = new night (this);						//this.addChild(this.sunny);			this.addChild(this.backgrnd);			this.addEventListener(Event.ENTER_FRAME,performFrameTest);						initKinect();			initForest();			initGestures();					}				public function initGestures() {			var rightHandDepthSwipe : DepthSwipe = new DepthSwipe(GesturePart.RIGHT_HAND);			rightHandDepthSwipe.dispatcher.addEventListener(KinectGestureEvent.FORWARD_SWIPE, zSwipe);			_actionManager.add(rightHandDepthSwipe);						var leftHandDepthSwipe : DepthSwipe = new DepthSwipe(GesturePart.LEFT_HAND);			leftHandDepthSwipe.dispatcher.addEventListener(KinectGestureEvent.FORWARD_SWIPE, zSwipe);			_actionManager.add(leftHandDepthSwipe);		}				public function initForest() {			//Add Trees to array			var zIndexer = 0;			for (var i:Number=0; i<10; i++) {				zIndexer += 600;				var zPos = zIndexer;				var tree = new trunk(this, zPos, i);				tree.cacheAsBitmap = true;				treeArray.push(tree);				};						//sort Tree Array so the right trees appears in front			treeArray.sortOn( "z", Array.NUMERIC | Array.DESCENDING );						//add stuff to stage			for (var t:Number=0; t<treeArray.length;t++){				this.addChild(treeArray[t]); 				};			addChild(this.loadingKinect);			this.addChild(this.nightly);			//stage.addEventListener(KeyboardEvent.KEY_DOWN, handleKeyDown);		}				public function initKinect() {			if (Kinect.isSupported()) {				device = Kinect.getDevice();				var settings:KinectSettings = new KinectSettings();				settings.skeletonEnabled = true;            	settings.skeletonMirrored = true;				settings.depthEnabled = true;				device.addEventListener(UserEvent.USERS_WITH_SKELETON_ADDED, skelIn);            	device.addEventListener(UserEvent.USERS_WITH_SKELETON_REMOVED, skelOut);								device.start(settings);				device.addEventListener(DeviceEvent.STARTED, _started);				_debugger = new KinectDebugger(device, true, true, false, false);				addChild(_debugger);				_actionManager = new ActionManager(stage.frameRate);			}			else { 			trace ("NO DEVICE"); 			}		}				private function zSwipe(event : KinectGestureEvent) : void		{			trace("DEPTH SWIPE GO!");			updateTreesZ(200);		}				private function _started(event : DeviceEvent) : void {			device.removeEventListener(DeviceEvent.STARTED, _started);			addEventListener(Event.ENTER_FRAME, _enterFrame);		}		private function _enterFrame(event : Event) : void		{			for each(var user : User in device.users)			{				//draw the kinect feedback in the debugger				_debugger.draw(user);								//ask your ActionManager to compute and analyze user's actions				_actionManager.compute(user);				}		}						public function skelIn(event:UserEvent):void {						trace("SKELETON ON!");			this.userOne = event.users[0];			_actionManager.compute(this.userOne);			_debugger.draw(this.userOne);			/*if (event.users.length == 0){				this.userOne = event.users[0];				userIn = true;			}			else if (event.users.length == 1){				this.userTwo = event.users[1];			}*/						var headPosX = this.userOne.skeletonJoints[0].position.depth.x*4;			var headPosZ = this.userOne.skeletonJoints[0].position.world.z;						var leftHandX = this.userOne.skeletonJoints[5].position.depth.x*4;			var leftHandY = this.userOne.skeletonJoints[5].position.depth.y*4;			var leftHandZ = this.userOne.skeletonJoints[5].position.world.z;			leftHand = new leftMarker(leftHandX, leftHandY);			//addChild(leftHand);						var rightHandX = this.userOne.skeletonJoints[8].position.depth.x*4;			var rightHandY = this.userOne.skeletonJoints[8].position.depth.y*4;			var rightHandZ = this.userOne.skeletonJoints[8].position.world.z;			rightHand = new rightMarker(rightHandX, rightHandY);			//addChild(rightHand);			//head = new headMarker(headPosX);			//sets up starting value so the movement difference can be measured. 						oldHeadX = headPosX;			oldTreeZ = rightHandZ;			if(this.loadingKinect.stage != null)  {          			removeChild(this.loadingKinect);   			};			//addChild(head);			device.addEventListener(UserEvent.USERS_UPDATED, updateSkel);					}				public function skelOut(event:UserEvent):void {			userIn = false;			trace("SKELETON OFF!");			removeChild(leftHand);			removeChild(rightHand);			event.users.pop();			device.removeEventListener(UserEvent.USERS_UPDATED, updateSkel);		}				//Takes new head position data and sends it the relevant environment update functions. 		public function updateSkel(event:UserEvent):void {			var headX = this.userOne.skeletonJoints[0].position.depth.x*4; 	  		var headZ = this.userOne.skeletonJoints[0].position.world.z; 			var treeXDiff = headX - oldHeadX;			oldHeadX = headX;						leftHand.x = this.userOne.skeletonJoints[5].position.depth.x*4;			leftHand.y = this.userOne.skeletonJoints[5].position.depth.y*4;			var updateLeftZ = this.userOne.skeletonJoints[5].position.depth.x*4;			var treeZDiff = headZ - oldTreeZ;			oldTreeZ = headZ;									rightHand.x = this.userOne.skeletonJoints[8].position.depth.x*4;			rightHand.y = this.userOne.skeletonJoints[8].position.depth.y*4;			//trace(treeZDiff);			/*if(treeZDiff > 20 || treeZDiff < -20) {				trace("UPDATEZ", treeZDiff);				updateTreesZ(treeZDiff);			};			//trace(treeXDiff);			if(treeXDiff > 40 || treeXDiff < -40) {				trace("UPDATEX", treeXDiff);				updateTreesX(treeXDiff); 			};*/					}				public function randomRange(minNum:Number, maxNum:Number):Number {			return (Math.floor(Math.random()*(maxNum - minNum +1)) + minNum);		}				//Back Up Keyboard function for debugging Tree Z movement. 		/*public function handleKeyDown(event:KeyboardEvent):void {			if(event.keyCode == 38) {				updateTreesZ(100);			}			else if(event.keyCode == 40) {				updateTreesZ(-100);			}		}*/						//Iterates over each tree and updates their X Position		public function updateTreesX(treeXDiff) {			for (var q:Number=0; q<this.treeArray.length;q++){				var currentTree = this.treeArray[q];				currentTree.cacheAsBitmap = true;				if (currentTree.z < 0) {					var positiveZ = -1*currentTree.z;				}				else {						positiveZ = currentTree.z;				};				var tweenerX = currentTree.x-(treeXDiff/((positiveZ+1000)/3000));				//trace(tweenerX);				currentTree.x = tweenerX;				/*Tweener.removeTweens(currentTree)				Tweener.addTween(currentTree, {							 x:tweenerX, 							 time:0.05							 });*/				};			//trace("Updated");		}				//Iterates over each tree and updates their z position and alpha		public function updateTreesZ(treeZDiff) {			//trace ("Update", treeZDiff);			for (var q:Number=0; q<treeArray.length;q++){				var currentTree = this.treeArray[q];				if(q == 9) {					var treeBehind = 1; 				}				else {					treeBehind = this.treeArray[q+1].z;				};				//trace(treeBehind);					currentTree.cacheAsBitmap = true;					//Tweener.removeTweens(currentTree)										//Adjusts scale depending on keyboard press/mouse scroll/gesture					if (currentTree.z > -600 && currentTree.z < 6000) {						var newZ = currentTree.z + treeZDiff;						currentTree.z += treeZDiff;						/*Tweener.addTween(currentTree, {							 z:newZ, 							 time:0.6							 });*/					}					else if (currentTree.z > 6000) {						if (treeZDiff < 0) {							currentTree.z += treeZDiff;							/*newZ = currentTree.z + treeZDiff;							Tweener.addTween(currentTree, {							 z:newZ, 							 time:0.6							 });*/						}					}					else if (currentTree.z < -600) {						if (treeZDiff > 0 && treeBehind > 0) {							trace("CURRENT", currentTree.z); 							trace("BEHIND", treeBehind);							currentTree.z += treeZDiff;							/*newZ = currentTree.z + treeZDiff;							Tweener.addTween(currentTree, {							 z:newZ, 							 time:0.6							 });*/						}					};										//Adjust opacity depending on zPos					if (currentTree.z < -100 && currentTree.z > -300) {						currentTree.alpha = 1-((currentTree.z+100)/-200);					}					else if (currentTree.z < -300) {						currentTree.alpha = 0;					}					else if (currentTree.z > 6000) {						currentTree.alpha = 0;					}					else if (currentTree.z > -100 && currentTree.z < 2000) {						currentTree.alpha = 1;					}					else if (currentTree.z < 6000 && currentTree.z > 2000) {						currentTree.alpha = 1-((currentTree.z-2000)/4000);					};													}					}								function performFrameTest(e:Event):void {			frames+=1;			curTimer=getTimer();			if(curTimer-prevTimer>=1000){			trace("FPS: "); trace(Math.round(frames*1000/(curTimer-prevTimer)));			prevTimer=curTimer;			frames=0;			}		}				public function tester() {			trace("TESTED OK!");		}					}}